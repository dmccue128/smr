/**
 * AbstractComponent.java
 * 2 Apr 2016
 * @author Daniel McCue
 */

package com.synadek.core;

import java.text.MessageFormat;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.simple.JSONObject;

/**
 * @formatter:off
 * 
 * Implementation of the abstract class, Component, includes three functions of a component:
 * 1) demographic info about the component (e.g., component name)
 * 2) component health status
 * 3) component configuration parameters
 * 
 * This class also provides translation services for components to format user messages.
 * 
 * @formatter:on
 */
public abstract class AbstractComponent implements Component {

	/**
	 * By default, resource bundle basename is package name followed by extension,
	 * ".Resources".
	 */
	private static final String RESOURCES_BUNDLE_EXTENSION = ".Resources";

	/**
	 * Error string returned from failed translation lookups.
	 */
	public static final String RESOURCE_ERROR = "translationError";

	/**
	 * JSON key for status messages.
	 */
	protected static final String KEY_SIMULATED = "simulated";

	/**
	 * JSON key for status messages.
	 */
	protected static final String KEY_CONNECTED = "connected";

	/**
	 * JSON key for status messages generated by subclasses to describe the status
	 * in getStatusMessage.
	 */
	protected static final String KEY_STATUS_MESSAGE = "statusMessage";

	/**
	 * Resource keys corresponding to status codes.
	 */
	private static final Map<Status, String> statusMap = Map.of(Status.ACTIVE, "status.active", Status.IMPAIRED,
			"status.impaired", Status.INACTIVE, "status.inactive");

	protected Configuration myConfiguration;

	/**
	 * Components that do not implement software simulation may log this error
	 * message.
	 */
	protected static final String ERR_SIM_NOT_AVAIL = "Simulation is not supported";

	/**
	 * Every component instance has a unique name established when the component is
	 * created. Component names do not change.
	 */
	private final String componentName;

	/**
	 * Components must be connected before use.
	 */
	protected boolean connected;

	/**
	 * Any component is potentially simulated.
	 */
	protected boolean simulated;

	/**
	 * Acquire a reference to the application logger.
	 */
	protected final Logger log = LogManager.getLogger(this.getClass().getPackage().getName());

	/**
	 * Default constructor.
	 */
	public AbstractComponent() {
		connected = false;
		simulated = false;
		// record the unique name of this component
		componentName = this.getClass().getSimpleName();
		myConfiguration = new Configuration(componentName, componentName);
		log.debug("Created component, {}", componentName);
	}

	/**
	 * Explicit constructor.
	 * 
	 * @param name is a unique name for this component instance
	 */
	public AbstractComponent(final String name) {
		connected = false;
		simulated = false;
		// record the unique name of this component
		componentName = name;
		myConfiguration = new Configuration(name, name);
		log.debug("Created component, {}", componentName);
	}

	/**
	 * Full constructor.
	 *
	 * @param name a unique name for this component instance
	 * @param desc a description of this component
	 */
	public AbstractComponent(final String name, final String desc) {
		connected = false;
		simulated = false;
		componentName = name;
		myConfiguration = new Configuration(name, desc);
		log.debug("Created component, {}", componentName);
	}

	/**
	 * Default connect implies non-simulated component.
	 * 
	 * @throws ComponentException if an error occurs
	 */
	@Override
	public boolean connect() throws ComponentException {
		return connect(false);
	}

	/**
	 * Default disconnect may be overridden by subclass.
	 * 
	 * @throws ComponentException if an error occurs
	 */
	@Override
	public void disconnect() throws ComponentException {
		if (connected) {
			connected = false;
			log.debug("Default disconnect for component {}", componentName);
		}
		simulated = false;
	}

	/**
	 * Format a user message based on a pattern and the preferred user locale using
	 * default resource bundle.
	 * 
	 * @param args        is the array of arguments to apply to the pattern
	 * @param resourceKey is the key to find the pattern to use for the formatting
	 * @param locale      is the locale for which the resources are sought
	 * @return localized message or the RESOURCE_ERROR string, "<error/>", if
	 *         resource not found
	 */
	protected final String formatUserMessage(final Object[] args, final String resourceKey, final Locale locale) {
		return formatUserMessage(null, args, resourceKey, locale);
	}

	/**
	 * Format a user message based on a pattern and the preferred user locale.
	 * 
	 * @param bundleName  is the base name of the resource bundle to use
	 * @param args        is the array of arguments to apply to the pattern
	 * @param resourceKey is the key to find the pattern to use for the formatting
	 * @param locale      is the locale for which the resources are sought
	 * @return localized message or the RESOURCE_ERROR string, "<error/>", if
	 *         resource not found
	 */
	protected final String formatUserMessage(final String bundleName, final Object[] args, final String resourceKey,
			final Locale locale) {

		// Find the pattern for the message
		final String pattern = userMessage(bundleName, resourceKey, locale);
		if (pattern == null || pattern.equals(RESOURCE_ERROR)) {
			return RESOURCE_ERROR;
		}

		// Format the message
		String result;
		try {
			final MessageFormat formatter = new MessageFormat(pattern, locale);
			result = formatter.format(args);
			if (result == null) {
				log.error("Formatting of resourceKey, {}, with pattern, {}, returned null", resourceKey, pattern);
				result = RESOURCE_ERROR;
			}
		} catch (NullPointerException npe) {
			log.error("Null pointer exception formatting user message, {}", resourceKey);
			result = RESOURCE_ERROR;
		} catch (IllegalArgumentException iae) {
			log.error("Illegal message format request using pattern, {}: {}", pattern, iae.getMessage());
			// pattern should always be valid -- print a stack trace to assist in debugging
			iae.printStackTrace();
			result = RESOURCE_ERROR;
		}
		return result;
	}

	/**
	 * getResourceBundle locates the most appropriate resource bundle for localizing
	 * messages for the user interface.
	 * 
	 * @param basename is the base name of the resource file to use. If null, a base
	 *                 name will be generated by appending
	 *                 RESOURCES_BUNDLE_EXTENSION to the package name.
	 * @param locale   is the locale for which the resources are sought or null for
	 *                 the default locale
	 * @return a resource bundle
	 */
	private ResourceBundle getBundle(final String basename, final Locale locale) {

		// Bundle name is generated from package name concatenated with ".Resources"
		if (basename == null) {
			final String pkg = this.getClass().getPackage().getName();
			final String resourceBaseName = pkg + RESOURCES_BUNDLE_EXTENSION;
			return getBundle(resourceBaseName, locale);
		}

		ResourceBundle result = null;

		// If undefined locale, return default locale
		if (locale == null) {
			result = ResourceBundle.getBundle(basename);
		} else {
			result = ResourceBundle.getBundle(basename, locale);
		}

		// Log error if resources cannot be located
		if (result == null) {
			log.error("getBundle returned null for locale, {}, and basename {}", locale, basename);
		}

		return result;
	}

	/**
	 * Return the name of the component instance.
	 * 
	 * @return the name
	 */
	@Override
	public final String getName() {
		return componentName;
	}

	/**
	 * Get status information about this component.
	 * 
	 * @param locale locale in which to present information
	 * @return the information
	 */
	@SuppressWarnings("unchecked")
	public JSONObject getStatus(Locale locale) {
		final JSONObject result = new JSONObject();
		result.put(KEY_CONNECTED, Boolean.valueOf(this.connected));
		result.put(KEY_SIMULATED, Boolean.valueOf(this.simulated));
		return result;
	}

	/**
	 * Return the current status of the component.
	 * 
	 * @return the status
	 */
	@Override
	public Status getStatusCode() {
		// For default implementation, connected ==> active
		Status sts = isConnected() ? Status.ACTIVE : Status.INACTIVE;
		log.debug("Default status code for component {}: {}", componentName, sts);
		return sts;
	}

	/**
	 * Return a localized message describing the status of the component.
	 * 
	 * @param locale is the locale in which the message should be generated. A null
	 *               locale parameter will return a message in the default locale.
	 * @return the message
	 */
	@Override
	public String getStatusMessage(Locale locale) {

		// Get status information from component if available
		final JSONObject status = getStatus(locale);

		// If the component status includes a formatted message, use it
		if (status != null && status.containsKey(KEY_STATUS_MESSAGE)) {
			return (String) status.get(KEY_STATUS_MESSAGE);
		}

		// Otherwise, generate a message from the elements in the status object
		String generatedMessage = null;

		// If component status includes info, use it to generate message
		if (status != null && !status.isEmpty()) {

			final StringBuilder sb = new StringBuilder();
			String sep = "";
			// Iterate over elements of status object, formatting the status msg
			for (@SuppressWarnings("unchecked")
			Iterator<String> iterator = status.keySet().iterator(); iterator.hasNext();) {
				String key = iterator.next();
				sb.append(sep);
				sb.append(key);
				sb.append('=');
				sb.append(status.get(key).toString());
				sep = ", ";
			}

			// Convert the StringBuilder contents to a String
			generatedMessage = sb.toString();
		}

		// If the status object contained no elements, use localized label for status
		// code
		if (generatedMessage == null || generatedMessage.length() == 0) {
			// Get resource key for the user message corresponding to object's status
			final String resourceKey = statusMap.get(getStatusCode());
			// Look up the localized string associated with this resource key
			generatedMessage = userMessage(resourceKey, locale);
		}

		return generatedMessage;
	}

	/**
	 * Default isConnected assumes a component is connected once created so always
	 * returns true. May be overridden by subclass where a more sophisticated
	 * connection logic is required.
	 * 
	 * @return true if the component is connected
	 */
	@Override
	public boolean isConnected() {
		return connected;
	}

	/**
	 * isSimulated returns true if the device or one of its subcomponents is
	 * simulated.
	 * 
	 * @return true if some or all of this component is simulated
	 */
	@Override
	public boolean isSimulated() {
		return simulated;
	}

	/**
	 * Return a user message based on preferred locale using default resource bundle
	 * for the class.
	 * 
	 * @param resourceKey is the key to find the pattern to use for the formatting
	 * @param locale      is the locale for which the resources are sought
	 * @return localized message or the RESOURCE_ERROR string, "translationError",
	 *         if resource not found
	 */
	protected final String userMessage(final String resourceKey, final Locale locale) {
		return userMessage(null, resourceKey, locale);
	}

	/**
	 * Return a user message based on preferred locale.
	 * 
	 * @param bundleName  is the base name of the resource bundle to use
	 * @param resourceKey is the key to find the pattern to use for the formatting
	 * @param locale      is the locale for which the resources are sought
	 * @return localized message or the RESOURCE_ERROR string, "translationError",
	 *         if resource not found
	 */
	protected final String userMessage(final String bundleName, final String resourceKey, final Locale locale) {

		String result;

		try {
			final ResourceBundle bundle = getBundle(bundleName, locale);
			if (bundle == null) {
				log.error("No such bundle: " + bundleName);
				return RESOURCE_ERROR;
			}

			result = bundle.getString(resourceKey);

			if (result == null) {
				log.error("No such resourceKey " + resourceKey);
				result = RESOURCE_ERROR;
			}

		} catch (NullPointerException npe) {
			log.error("Failed attempt to look up a null resource key: " + npe.getMessage());
			// key should never be null -- print a stack trace to assist in
			// debugging
			npe.printStackTrace();
			result = RESOURCE_ERROR;
		} catch (MissingResourceException mre) {
			// Log the error that the resource was not defined or key was
			// misspelled
			log.error("Failed attempt to look up user resource key, " + resourceKey + ": " + mre.getMessage());
			// In default, use the untranslated resource key as the message
			result = RESOURCE_ERROR;
		} catch (ClassCastException cce) {
			log.error("Non-string result from look up of user resource key, " + resourceKey + ": " + cce.getMessage());
			// result should always be a string -- print a stack trace to assist
			// in debugging
			cce.printStackTrace();
			result = RESOURCE_ERROR;
		}

		return result;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.synadek.core.Component#getConfiguration()
	 */
	@Override
	public Configuration getConfiguration() {
		return myConfiguration;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.synadek.core.Component#getConfigurationSchema()
	 */
	@Override
	public JSONObject getConfigurationSchema() {
		return new JSONObject();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.synadek.core.Component#resetConfiguration()
	 */
	@Override
	public void resetConfiguration() {
		// Empty the configuration of this component
		myConfiguration.clear();
	}
}
